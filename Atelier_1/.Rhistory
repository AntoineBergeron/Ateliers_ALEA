if (result == 1){
n <- n+1
}
}
reponse <- n_test/n
val_de <- seq(1:6)
n_test <- 60000
n <- 0
for (i in 1:n_test){
result <- sample(val_de,1)
if (result == 1){
n <- n+1
}
}
reponse <- n_test/n
val_de <- seq(1:6)
n_test <- 60000
n <- 0
for (i in 1:n_test){
result <- sample(val_de,1)
if (result == 1){
n <- n+1
}
}
reponse <- n_test/n
val_de <- seq(1:6)
n_test <- 60000
n <- 0
for (i in 1:n_test){
result <- sample(val_de,1)
if (result == 1){
n <- n+1
}
}
reponse <- n_test/n
valeurs <- c("2", "3", "4", "5", "6", "7", "8", "9", "10", "valet", "dame", "roi", "as")
couleurs <- rep(c("pique", "trèfle", "carreau", "coeur"), each = 13)
cartes <- paste(valeurs "-" couleurs)
cartes <- paste(valeurs ,"-", couleurs)
cartes
cartes <- paste(valeurs ,"de", couleurs)
cartes
valeurs <- c("2", "3", "4", "5", "6", "7", "8", "9", "10", "Valet", "Dame", "Roi", "As")
couleurs <- rep(c("pique", "trèfle", "carreau", "coeur"), each = 13)
cartes <- paste(valeurs ,"de", couleurs)
cartes
tirage <- function(n, cartes){
sample(x = cartes, size = n, replace = FALSE)
}
tirage(7,cartes)
tirage <- function(n){
sample(x = cartes, size = n, replace = FALSE)
}
tirage(7)
nb_heure <- 240/60
distance <- 100 * nb_heure
var1 <- 100
var2 <- 0.56
nombre <- var1 * var2
res <- numeric(100)
for (i in 1:100){
res[i] <- nombre/i + 1
}
moy <- mean(res)
if(moy < 2){
print("Oh-Oh!")
} else{
print("HiHi!")
}
var1 <- 100
var2 <- 0.056
nombre <- var1 * var2
res <- numeric(100)
for (i in 1:100){
res[i] <- nombre/i + 1
}
moy <- mean(res)
if(moy < 2){
print("Oh-Oh!")
} else{
print("HiHi!")
}
valeurs <- 1:6
nb_lancer <- 1
result <- sample(valeurs,1)
while (result != 6) {
result <- sample(valeurs,1)
nb_lancer <- nb_lancer + 1
}
valeurs <- 1:6
nb_lancer <- 1
result <- sample(valeurs,1)
while (result != 6) {
result <- sample(valeurs,1)
print(result)
nb_lancer <- nb_lancer + 1
}
valeurs <- 1:6
nb_lancer <- 1
result <- sample(valeurs,1)
while (result != 6) {
result <- sample(valeurs,1)
print(result)
nb_lancer <- nb_lancer + 1
}
valeurs <- 1:6
nb_lancer <- 1
while (result != 6) {
result <- sample(valeurs,1)
print(result)
nb_lancer <- nb_lancer + 1
}
NbOrange_1 <- round(rnorm(1, mean = 48, sd = 1))
NbOrange_2 <- 0
while (NbOrange_1 > 0) {
NbOrange_1 <- NbOrange_1 - 1
NbOrange_2 <- NbOrange_2 + 1
}
NbOrange_1 <- round(rnorm(1, mean = 48, sd = 1))
NbOrange_2 <- 0
while (NbOrange_1 > 0) {
NbOrange_1 <- NbOrange_1 - 1
NbOrange_2 <- NbOrange_2 + 1
}
NbOrange_1 <- round(rnorm(1, mean = 48, sd = 1))
NbOrange_2 <- 0
while (NbOrange_1 > 0) {
NbOrange_1 <- NbOrange_1 - 1
NbOrange_2 <- NbOrange_2 + 1
}
####### Julie et la somme de 1 à 79 ##########
val_som <- 0
for (i in 1:79){
val_som <- val_som + i
}
14*14
16*12
2 + 16 * 24 - 56
19*24
16*24
getwd()
getwd()
3 + 3
3*3
3 + 3
3 + 3
3 + 3
3 * 4
12/3
3 + 3
3 * 4
12/3
2 + 16 * 24 - 56
2 + (16 * 24) - 56
1 * 10^(-6)
1 * 10^(-6)
1 * 10^(-6)
0.000001
# Assignons la valeur 5 à l'objet a
a <- 5
a
b
# Assignons le caractère a à l'objet b
b <- "a"
b
# Assignons le caractère 7 à l'objet c
c <- "7"
c
# Assignons la valeur 5 à l'objet a
a <- 5
a
# Assignons le caractère a à l'objet b
b <- "a"
b
c
c
c
c
# Assignons la valeur 5 à l'objet a
a <- 5
a
b
# Assignons le caractère a à l'objet b
b <- "a"
b
# Assignons le caractère 7 à l'objet c
c <- "7"
c
# Assignons l'objet a à l'objet d
d <- a
d
# Pouvons nous effectuer a + c?
a + c
# Création d'un vecteur
Etudiant1 <- c(70,82,59,94,77)
# Création d'un deuxième vecteur
Etudiant2 <- c(63,80,64,88,79)
# Français, Mathématique, Histoire, Anglais, Éducation Physique
# Création d'un vecteur
Etudiant1 <- c(70,82,59,94,77)
# Création d'un deuxième vecteur
Etudiant2 <- c(63,80,64,88,79)
library(tidyverse) # Stepwise Logistic Regression
library(caret) # Stepwise Logistic Regression
library(MASS) # Stepwise Logistic Regression
library(glmnet) # Arriver a bien capter les bons prédicteurs
library(copula) # Estimation à l'aide de copules
library(VineCopula) # Estimation à l'aide de copules
library(rvinecopulib) # Estimation à l'aide de copules
library(ggraph) # Graphique des copules
donnees <- read.table(file = 'C:/Users/bera1923/Desktop/CeCS - Consultations/Clients et Clientes/Zidane Toffa/donnees.txt', sep = "\t", header = TRUE)
Att <- donnees[,1]                   # Copie la première colonne
donnees <- donnees[,-1]              # Enlève la première colonne
donneesFinal <- cbind(donnees,Att)   # Colle la copie à la fin du tableau
colnames(donneesFinal) <- c("RecBro", "Rxt", "Slot", "Snir", "Tim", "TotBusy", "TotLost", "Att")
set.seed(12)
echaEntr <- donneesFinal$Att %>%
createDataPartition(p = 0.8, list = FALSE)    # 80% pour entraînement, 20% pour Test
donneesEntr  <- donneesFinal[echaEntr, ]  # données d'entraînement
donneesTest <- donneesFinal[-echaEntr, ]  # données test
# Pour le modèle lasso
x <- model.matrix(Att~., donneesEntr)[,-1]   # Sur R, on doit séparer les variables x et y pour Lasso
y <- donneesEntr$Att                         # On obtient x et y ainsi
cv.lasso <- cv.glmnet(x, y, alpha = 1, family = "binomial")
# Fit le modèle final sur les données d'entraînement
model.lasso <- glmnet(x, y, alpha = 1, family = "binomial",
lambda = cv.lasso$lambda.min)
# Coefficients de la régression
coef(model.lasso)
# Prédictions
x.test <- model.matrix(Att ~., donneesTest)[,-1]
prob <- model.lasso %>% predict(newx = x.test)
ClassPred <- ifelse(prob > 0.5, 1, 0)
# Précision
ClassObs <- donneesTest$Att
mean(ClassPred == ClassObs)
# Stepwise model
step.model <- glm(Att ~., data = donneesEntr, family = binomial, control = glm.control(maxit = 50)) %>%
stepAIC(trace = TRUE)
# Coefficients de la régression
coef(step.model)
summary(step.model)
# Prédictions
prob <- predict(step.model, donneesTest, type = "response")
ClassPred <- ifelse(prob > 0.5, 1, 0)
# Précision
ClassObs <- donneesTest$Att
mean(ClassPred==donneesEntr$Att)
cor(donneesFinal, method = "pearson")
col1 <- donneesFinal[,1]  # RecBro
col2 <- donneesFinal[,2]  # Rxt
col3 <- donneesFinal[,6]  # TotBusy
col4 <- donneesFinal[,8]  # Att
ntabFinal <- cbind.data.frame(col1,col2,col3,col4)           # coller les 4 colonnes
colnames(ntabFinal) <- c("RecBro", "Rxt", "TotBusy", "Att")  # renommer les colonnes
ntabFinal
es_p <- mean(ntabFinal[,4])   # Effectue la moyenne des Att (Somme des 0 et 1 divisé en n = 240 attaques)
es_p   # la probabilité d'attaque est de 0.2083333
Fn_1 <- ecdf(ntabFinal[,1])  # Fonction de répartition empirique
Fn_2 <- ecdf(ntabFinal[,2])  # Fonction de répartition empirique
Fn_3 <- ecdf(ntabFinal[,3])  # Fonction de répartition empirique
plot(Fn_1, verticals = TRUE, do.points = FALSE, main = "Fonction de répartition de la variable RecBro")
plot(Fn_2, verticals = TRUE, do.points = FALSE, main = "Fonction de répartition de la variable Rxt")
plot(Fn_3, verticals = TRUE, do.points = FALSE, main = "Fonction de répartition de la variable TotBusy")
matF <- matrix(NA, nrow = nrow(ntabFinal), ncol = ncol(ntabFinal)-1)     # Création de la matrice des répartition
matF[,1] <- nrow(ntabFinal) / (nrow(ntabFinal)+1) * Fn_1(ntabFinal[,1])  # première colonne (Rescaled distribution)
matF[,2] <- nrow(ntabFinal) / (nrow(ntabFinal)+1) * Fn_2(ntabFinal[,2])  # deuxième colonne (Rescaled distribution)
matF[,3] <- nrow(ntabFinal) / (nrow(ntabFinal)+1) * Fn_3(ntabFinal[,3])  # troisième colonne (Rescaled distribution)
matF
MatntabFinal <- as.matrix(ntabFinal)
# Copules: 1 = Gaussienne, 2 = Student, 3 = Gumbel, 4 = Clayton, 5 = Frank, 6 = Joe,
coefficient <- function(copule, matrice){
if(copule == 1){
cop <- normalCopula(dim = 3)
t <- "La copule gaussienne possède un paramètre égal à"
} else if(copule == 2){
cop <- tCopula(dim = 3)
t <- "La copule Student possède un paramètre égal à"
} else if(copule == 3){
cop <- gumbelCopula(dim = 3)
t <- "La copule Gumbel possède un paramètre égal à"
} else if(copule == 4){
cop <- claytonCopula(dim = 3)
t <- "La copule Clayton possède un paramètre égal à"
} else if(copule == 5){
cop <- frankCopula(dim = 3)
t <- "La copule de Frank possède un paramètre égal à"
} else if(copule == 6){
cop <- joeCopula(dim = 3)
t <- "La copule de Joe possède un paramètre égal à"
}
fit <- fitCopula(cop, matrice, method = "mpl")
return(list((paste(t, coef(fit), sep = " ")),coef(fit)))
}
coefficient(1,matF)
param_gauss <- unname(coefficient(1,matF)[2][[1]])  # paramètre de la copule gaussienne
coefficient(2,matF)                                 # possède le paramètre ainsi que le degré de liberté!
param_stud <- unname(coefficient(2,matF)[2][[1]])   # paramètres de la copule de Student
coefficient(3,matF)
param_gumb <- unname(coefficient(3,matF)[2][[1]])  # paramètre de la copule Gumbel
coefficient(4,matF)
param_clay <- unname(coefficient(4,matF)[2][[1]])  # paramètre de la copule Clayton
coefficient(5,matF)
param_frank <- unname(coefficient(5,matF)[2][[1]])  # paramètre de la copule Frank
coefficient(6,matF)
param_joe <- unname(coefficient(6,matF)[2][[1]])  # paramètre de la copule Joe
t_max <- nrow(ntabFinal)
Func_gauss = function(x,t) log(dCopula(c(matF[t,1],matF[t,2],matF[t,3]),normalCopula(param_gauss, dim = 3)))
vrais_gauss = sum(sapply(1:t_max, function(t) Func_gauss(x,t)))
Func_stud = function(x,t) log(dCopula(c(matF[t,1],matF[t,2],matF[t,3]),tCopula(param = param_stud[1], df = param_stud[2] , dim = 3)))
vrais_stud = sum(sapply(1:t_max, function(t) Func_stud(x,t)))
Func_gumb = function(x,t) log(dCopula(c(matF[t,1],matF[t,2],matF[t,3]),gumbelCopula(param_gumb, dim = 3)))
vrais_gumb = sum(sapply(1:t_max, function(t) Func_gumb(x,t)))
Func_clay = function(x,t) log(dCopula(c(matF[t,1],matF[t,2],matF[t,3]),claytonCopula(param_clay, dim = 3)))
vrais_clay = sum(sapply(1:t_max, function(t) Func_clay(x,t)))
Func_frank = function(x,t) log(dCopula(c(matF[t,1],matF[t,2],matF[t,3]),frankCopula(param_frank, dim = 3)))
vrais_frank = sum(sapply(1:t_max, function(t) Func_frank(x,t)))
Func_joe = function(x,t) log(dCopula(c(matF[t,1],matF[t,2],matF[t,3]),joeCopula(param_joe, dim = 3)))
vrais_joe = sum(sapply(1:t_max, function(t) Func_joe(x,t)))
logvraisemblance_des_cop = c(vrais_gauss,vrais_stud,vrais_gumb,vrais_clay,vrais_frank,vrais_joe)
AIC_des_modeles = 2 - 2*(logvraisemblance_des_cop)
BIC_des_modeles = log(nrow(ntabFinal)) - 2 * logvraisemblance_des_cop
tableauAIC <- t(as.data.frame(AIC_des_modeles))
colnames(tableauAIC) <- c("Gauss", "Student", "Gumbel", "Clayton", "Frank", "Joe")
tableauAIC
tableauBIC <- t(as.data.frame(BIC_des_modeles))
colnames(tableauBIC) <- c("Gauss", "Student", "Gumbel", "Clayton", "Frank", "Joe")
tableauBIC
if(isTRUE(which.min(tableauAIC) == which.min(tableauBIC))){
copgagn <- which.min(tableauAIC)
} else
"Nous avons un problème au AIC/BIC"
testing1 <- 1 - dCopula(matfinal, copula = tCopula(param_stud[1], df = param_stud[2], ,dim = 4))
estim_prob <-
###### TEST cCopula
col4 <- rep((1 - es_p), times = 240)
matfinal <- cbind(matF,col4)
testing1 <- 1 - dCopula(matfinal, copula = tCopula(param_stud[1], df = param_stud[2], ,dim = 4))
testing1
testing1 <- 1 - dCopula(matF, copula = tCopula(param_stud[1], df = param_stud[2], ,dim = 4))
testing1 <- 1 - dCopula(matF, copula = tCopula(param_stud[1], df = param_stud[2], ,dim = 3))
testing1
?dcopula
?dCopula
testing1 <- 1 - dCopula(copula = tCopula(param_stud[1], u = matF, df = param_stud[2], ,dim = 3))
testing1 <- 1 - dCopula(copula = tCopula(param_stud[1], matF, df = param_stud[2], ,dim = 3))
testing1 <- 1 - dCopula(copula = tCopula(param_stud[1], df = param_stud[2], ,dim = 3), matF)
testing1
tau <- 0.5
theta <- iTau(claytonCopula(), tau = tau)
d <- 2
cc <- claytonCopula(theta, dim = d)
n <- 1000
set.seed(271)
## A small u_1
u1 <- 0.05
U <- cCopula(cbind(u1, runif(n)), copula = cc, inverse = TRUE)
View(U)
cc <- tCopula(param_stud[1], df = param_stud[2], dim = 3)
matfinal <- cbind(col4,matF)
matfinal
U <- cCopula(matfinal, copula = cc, inverse = FALSE)
View(U)
tau <- 0.5
theta <- iTau(claytonCopula(), tau = tau)
d <- 5
cc <- claytonCopula(theta, dim = d)
set.seed(271)
n <- 1000
U <- rCopula(n, copula = cc)
X <- qnorm(U) # X now follows a meta-Clayton model with N(0,1) marginals
U <- pobs(X) # build pseudo-observations
fN <- fitCopula(normalCopula(dim = d), data = U) # fit a Gauss copula
U.RN <- cCopula(U, copula = fN@copula)
splom2(U.RN, cex = 0.2) # visible but not so clearly
f.t <- fitCopula(tCopula(dim = d), U)
U.Rt <- cCopula(U, copula = f.t@copula) # transform with a fitted t copula
splom2(U.Rt, cex = 0.2) # still visible but not so clear
## Inverse (and check consistency)
U.N <- cCopula(U.RN, copula = fN @copula, inverse = TRUE)
U.t <- cCopula(U.Rt, copula = f.t@copula, inverse = TRUE)
tol <- 1e-14
stopifnot(
all.equal(U, U.N),
all.equal(U, U.t),
all.equal(log(U.RN),
cCopula(U, copula = fN @copula, log = TRUE), tolerance = tol),
all.equal(log(U.Rt),
cCopula(U, copula = f.t@copula, log = TRUE), tolerance = tol)
)
###Définissons les variables
nb_var <- 5
secteur <- c("Outaouais", "Laurentides", "Lanaudière", "Mauricie", "Capitale-Nationale", "Chaudières-Appalaches",
"Centre-du-Québec", "Montérégie", "Estrie")
pres_att <- c("Oui","Non")
pass_att <- c("Oui","Non")
age <- c(18:70)
jour_hopital <- c(0:15)
ndonnees <- 10000
donnees <- matrix(data = NA, nrow = ndonnees, ncol = nb_var)
for (i in 1:ndonnees){
donnees[i,] <- c((sample(secteur, prob = c(1/18,1/18,1/18,1/9,2/9,1/18,1/9,2/9,1/9))[1]), sample(pres_att, prob = c(1/10,9/10))[1], sample(pass_att, prob = c(3/10,7/10))[1], sample(age)[1],1)
}
for (i in 1:ndonnees){
if(donnees[i,2] == donnees[i,3] & donnees[i,2] == "Oui"){
donnees[i,2] <- "Non"
}
}
for (i in 1:ndonnees){
if(donnees[i,2] == "Non" & donnees[i,3] == "Non"){
donnees[i,5] <- 0
}else if(donnees[i,2] == "Oui"){
donnees[i,5] <- sample(jour_hopital, prob = c(0.5,0.07,0.04,0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.03))[1]
}else if(donnees[i,3] == "Oui"){
donnees[i,5] <- sample(jour_hopital, prob = c(0.35,0.08,0.05,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04))[1]
}
}
colnames(donnees) <- c("Région","Possède la Divoc-91 présentement", "A déjà eu la Divoc-91", "Âge de l'individu", "Nombre de jours passé à l'hôpital")
df_donnees <- as.data.frame(donnees, row.names = F)
write.table(df_donnees, file = "./donnees/ExerciceRecapitulatif.csv", sep = ";", row.names = F)
#####Charger les données:
donnees <-  read.table(file = './donnees/ExerciceRecapitulatif.csv', sep=";", header = TRUE)
#####Changement des noms de colonnes:
colnames(donnees) <- c("region", "pres_att", "pass_att", "age", "jour_hop")
#####Créer un tableau du nombre de jours qu'un patient à passé à l'hôpital (ligne) en fonction de sa région (colonne):
tab_jour_reg <- table(donnees$jour_hop, donnees$region)
setwd("C:/Users/bera1923/Desktop/Ateliers_ALEA/Atelier_1")
#####Charger les données:
donnees <-  read.table(file = 'donnees/ExerciceRecapitulatif.csv', sep=";", header = TRUE)
#####Changement des noms de colonnes:
colnames(donnees) <- c("region", "pres_att", "pass_att", "age", "jour_hop")
#####Créer un tableau du nombre de jours qu'un patient à passé à l'hôpital (ligne) en fonction de sa région (colonne):
tab_jour_reg <- table(donnees$jour_hop, donnees$region)
#####Trouver combien de personne ont été à l'hôpital pour la région de la Montérégie et de l'Estrie:
result1 <- c(sum(tab_jour_reg[,8])-tab_jour_reg[1,8],sum(tab_jour_reg[,4])-tab_jour_reg[1,4])
#####Trouver la moyenne des deux régions
result2 <- mean(result1)
#####Créer un vecteur des frais:
frais_hop <- c(10,10,10,5,10,5,5,15,5)
#####Combiner le vecteur des frais avec le tableau
nouv_tableau <- rbind(tab_jour_reg,frais_hop)
#####Ajouter un nom pour les lignes:
jour_hop <- c(c(0:15),"Frais")
nouv_tab_final <- cbind(jour_hop,nouv_tableau)
nouv_tab_final
nouv_tab_final <- numeric(cbind(jour_hop,nouv_tableau))
#####Charger les données:
donnees <-  read.table(file = 'donnees/ExerciceRecapitulatif.csv', sep=";", header = TRUE)
#####Changement des noms de colonnes:
colnames(donnees) <- c("region", "pres_att", "pass_att", "age", "jour_hop")
#####Créer un tableau du nombre de jours qu'un patient à passé à l'hôpital (ligne) en fonction de sa région (colonne):
tab_jour_reg <- table(donnees$jour_hop, donnees$region)
tab_jour_reg
#####Trouver combien de personne ont été à l'hôpital pour la région de la Montérégie et de l'Estrie:
result1 <- c(sum(tab_jour_reg[,8])-tab_jour_reg[1,8],sum(tab_jour_reg[,4])-tab_jour_reg[1,4])
#####Trouver la moyenne des deux régions
result2 <- mean(result1)
result1
result2
#####Ajouter un nom pour les lignes:
rownames(nouv_tableau) <- c("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","frais")
#####Créer un vecteur des frais:
frais_hop <- c(10,10,10,5,10,5,5,15,5)
#####Combiner le vecteur des frais avec le tableau
nouv_tableau <- rbind(tab_jour_reg,frais_hop)
#####Ajouter un nom pour les lignes:
rownames(nouv_tableau) <- c("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","frais")
View(nouv_tableau)
View(nouv_tableau)
ButsResult <- read.table(file = "donnees/ButsResult.txt", sep="\t", header = TRUE)
ButsResult
ButsMoyen <- c()
ButsMoyen[1] <- (ButsResult[1,1]*0 + ButsResult[2,1]*1 + ButsResult[3,1]*2 + ButsResult[4,1]*3 + ButsResult[5,1]*4 + ButsResult[6,1]*5)/sum(ButsResult[,1])
ButsMoyen[2] <- (ButsResult[1,2]*0 + ButsResult[2,2]*1 + ButsResult[3,2]*2 + ButsResult[4,2]*3 + ButsResult[5,2]*4 + ButsResult[6,2]*5)/sum(ButsResult[,2])
ButsMoyen[3] <- (ButsResult[1,3]*0 + ButsResult[2,3]*1 + ButsResult[3,3]*2 + ButsResult[4,3]*3 + ButsResult[5,3]*4 + ButsResult[6,3]*5)/sum(ButsResult[,3])
ButsMoyen
ButsMoyen2 <- c()
for(j in 1:3){
reponse <- 0
for (i in 1:6) {
reponse <- reponse + ButsResult[i,j]*(i-1)
}
ButsMoyen2[j] <- reponse/sum(ButsResult[,j])
}
ButsMoyen2
ButsResult
c(1,2,3,4,5) * ButsResult
ButsResult <- read.table(file = "donnees/ButsResult.txt", sep="\t", header = TRUE)
ButsResult
ButsMoyen <- c()
ButsMoyen[1] <- (ButsResult[1,1]*0 + ButsResult[2,1]*1 + ButsResult[3,1]*2 + ButsResult[4,1]*3 + ButsResult[5,1]*4 + ButsResult[6,1]*5)/sum(ButsResult[,1])
ButsMoyen[2] <- (ButsResult[1,2]*0 + ButsResult[2,2]*1 + ButsResult[3,2]*2 + ButsResult[4,2]*3 + ButsResult[5,2]*4 + ButsResult[6,2]*5)/sum(ButsResult[,2])
ButsMoyen[3] <- (ButsResult[1,3]*0 + ButsResult[2,3]*1 + ButsResult[3,3]*2 + ButsResult[4,3]*3 + ButsResult[5,3]*4 + ButsResult[6,3]*5)/sum(ButsResult[,3])
ButsMoyen
ButsMoyen2 <- c()
for(j in 1:3){
reponse <- 0
for (i in 1:6) {
reponse <- reponse + ButsResult[i,j]*(i-1)
}
ButsMoyen2[j] <- reponse/sum(ButsResult[,j])
}
ButsMoyen2
ButsResult
matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3)
VecBut <- c(0:5)
VecBut
tableau <- VecBut * ButsResult
tableau
colSums(tableau)
ButsMoyen3 <- colSums(tableau)/colSums(ButsResult)
ButsMoyen3

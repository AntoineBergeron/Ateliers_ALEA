- Nom des colonnes
- Entrées vides
- Présence de caractères invisibles
- Mauvais encodage des données
- Type de données et d'objets
---
# Écrire des fichiers `CSV` et `txt`
Il y a une grande diversité de façons d'enregistrer sur le disque des objets provenant de R. La façon la plus simple, versatile et qui permet les échanges entre différents logiciels et systèmes d'exploitation est d'écrire sous format `CSV`.
La syntaxe pour écrire une `matrice` ou un `data.frame` est aussi simple que pour lire un fichier `CSV`.
```{r eval=FALSE}
mat2 <- matrix(runif(n = 50,min = 0,max = 1),nrow = 5,ncol = 10)
write.table(mat2, file = "mat.csv")
```
---
# Écrire des fichiers `.Rdata` avec `save()`
Parfois les objets que l'on souhaite enregistrer ont une structure plus complexe qu'un tableau de données. R permet d'enregistrer ces objets dans un format qui lui est unique, le `.Rdata`. Ces objets sont compressés pour minimiser l'espace disque et ne peuvent être lus uniquement par R.
```{r}
MaListe <- list()
MaListe[[1]] <- 1
MaListe[[2]] <- c(1:10)
save(MaListe, file = "MaListe.Rdata")
```
**NOTE** - `save()` permet également de sauvegarder plusieurs objets.
```{r eval=FALSE}
save(MaListe,MonDataFrame, file = "MaListe.Rdata")
```
---
# Lire des fichiers `.Rdata` avec `load()`
Puisque le fichier `.Rdata` est spécifique à R, il s'agit peut-être du format le plus facile à lire puisque R prend en charge la mise en forme de l'objet, les noms et les types de données
```{r}
load("MaListe.Rdata")
ls()
```
---
# Lire des fichiers: `load()` et `.Rdata`
Faites attention, si le nom de l'objet contenu dans le fichier `.Rdata` est le même qu'un objet en mémoire, il va écraser ce premier objet.
```{r}
MaListe <- list("Hello","World")
load("MaListe.Rdata")
MaListe
```
## Pour éviter cette erreur, il faut utiliser les fonctions `saveRDS()` et `readRDS()`.
---
# Quelques commandes utiles
Il est important de vérifier la structure de l'objet après son importation dans l'environnement R.
```{r}
head(NHL, n = 3)
tail(NHL, n = 3)
```
---
# Quelques commandes utiles
Il est important de vérifier la structure de l'objet après son importation dans l'environnement R.
```{r}
str(NHL)
```
---
# Quelques commandes utiles
`summary()` permet d'obtenir un résumé du contenu de chaque colonne
```{r}
summary(NHL)
```
---
# Quelques commandes utiles
Très souvent, on souhaite réaliser un sommaire de nos données. La fonction `summary()` est fort utile, mais parfois on souhaite avoir d'autres informations que la moyenne (p. ex. la variance). Dans ce cas, la fonction `table()` est recommandée.
```{r}
PointsAN <- table(NHL$PPPoints)
PointsAN
```
---
# Exercice de manipulation des données
- Ouvrir le fichier [ButsDesNumPos.csv](./donnees/ButsDesNumPos.csv) au moyen de Excel ou d'un éditeur de texte
- Calculer le nombre moyen de buts en désavantage numérique pour chacune des positions
- Ouvrir le même fichier au moyen de R
- Vérifier que le fichier a le format approprié
- Créer un vecteur `ButsMoyen` d'une longueur correspondant au nombre de positions distinctes dans le fichier de données
---
# Exercice de manipulation des données (suite)
- Calculer le nombre moyen de buts en désavantage numérique pour chacune des positions au moyen de la fonction 'mean' et l'inscrire dans chaque position de `ButsMoyen`
- Convertir ButsMoyen en `data.frame`
- Attribuer les noms des positions pour chaque entrée de `ButsMoyen`
- Enregistrer `ButsMoyen` sous forme de fichier `CSV` (séparateur point-virgule)
- Ouvrir le fichier `CSV` et le comparer au calcul fait aux moyennes d’Excel
**Note:** vous pouvez explorer les données avec `summary`. Les plus avancés peuvent explorer la commande `apply`...
---
class: middle, center, inverse
# Manipulation des données
<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>
---
# Différents outils pour générer des données
```{r}
seq(from = 1, to = 10, by = 0.5)
rep(c(1:3), times = 3)
```
---
# Différents outils pour générer des données
```{r}
v1 <- c(1:3)
v2 <- c("A","B","C")
expand.grid(v1,v2)
```
---
# Combiner des objets
```{r}
rbind(v1,v2)
cbind(v1,v2)
```
---
# Fonctions utiles: trier des objets
```{r}
tri <- runif(n = 10, min = 0, max = 100)
tri
sort(tri)
```
---
# Fonctions utiles: obtenir des rangs
```{r}
rang <- runif(n = 10, min = 0, max = 100)
rang
rank(rang)
```
---
# Fonctions utiles: éch. les valeurs uniques
```{r}
uq <- c(1,2,5,7,4,3,2,1,10,5,8)
uq
unique(uq)
```
---
# Sous-échantillonner des objets
Parfois, on souhaite avoir seulement une partie des données contenues dans un objet. La fonction `subset()` est fort pratique pour réaliser cette opération.
Ici par exemple, on souhaite étudier seulement les joueurs de centre ayant fait au moins un but en désavantage numérique:
```{r}
NHL <- read.table(file="donnees/NHL.csv", header=TRUE, stringsAsFactors=FALSE, sep = ";")
sub_Centres <- subset(NHL, NHL$pos == "C" & NHL$Shpoints >= 1)
head(sub_Centres, n=2)
```
Le "==" est utilisé pour sélectionner les individus qui sont des joueurs de centre et le symbole "&" pour combiner deux conditions.
---
# Exercice
Le fichier [NHL_Complet.csv](./donnees/NHL_Complet.csv) est un sommaire de données individuelles d'environ 100 joueurs de la ligne nationale de hockey. On s'intéresse à connaitre la position jouée par ces joueurs en prenant en compte la division de leur équipe.
1. Charger les données "NHL_Complet".
2. Partitionner les données en fonction des divisions.
3. Pour chacune des divisions, calculer le nombre de joueurs jouant à chacune des positions.
4. Enregistrer les résultats dans un tableau où les étiquettes de rangées sont les divisions et les étiquettes des colonnes sont les positions.
On vous demande de rédiger un script qui réalisera l'ensemble de ces étapes, de la lecture des données à l'enregistrement du tableau final.
install.packages("xaringan")
library(xaringan)
head(parties)
parties <- read.table(file = './donnees/parties.txt', sep="\t", header = TRUE)
head(parties)
ButsResult <- table(parties$but.pour,parties$resultats)
View(parties)
ButsResult <- table(parties$But.pour,parties$Resultats)
parties
parties$Buts.pour
table(parties$Buts.pour,parties$Resultat)
ButsResult <- table(parties$Buts.pour,parties$Resultat)
head(ButsResult)
round(cor(ButsResult),6)
plot(ButsResult)
plot(cor(ButsResult))
ButsResult
plot(ButsResult)
n_t = 7000
lambda = 0.2
for t in 1:100
n_t = n_t * lambda
print n_t
let = ["R","S","T","U","D","I","O"]
let = c("R","S","T","U","D","I","O")
let[3]
let = c("Rally","S","T","U","Dodo","I","O")
let[3]
let[1]
let[5]
let
x <- c(1,7,5,3,9)
is.unsorted(x)
while (is.unsorted(x) = TRUE) {
for pos in 1:4
if{ x_temp[pos] > x_temp[pos+1]
x_temp[pos] <- x[pos+1]
x_temps[pos+1] <- x[pos]
}
x <- x_temp
}
x_temp <- c(1,7,5,3,9)
while (is.unsorted(x) = TRUE) {
for pos in 1:4
if{ x_temp[pos] > x_temp[pos+1]
x_temp[pos] <- x[pos+1]
x_temps[pos+1] <- x[pos]
}
x <- x_temp
}
while (is.unsorted(x) = TRUE) {
for pos in 1:4
if{ x_temp[pos] > x_temp[pos+1]
x_temp[pos] <- x[pos+1]
x_temps[pos+1] <- x[pos]
}
x <- x_temp
}
while (is.unsorted(x) = TRUE) {
for (pos in 1:4)
if{ x_temp[pos] > x_temp[pos+1]
x_temp[pos] <- x[pos+1]
x_temps[pos+1] <- x[pos]
}
x <- x_temp
}
while (is.unsorted(x) = TRUE) {
for (pos in 1:4)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temps[pos+1] <- x[pos]
}
x <- x_temp
}
x_temp <- c(1,7,5,3,9)
x <- c(1,7,5,3,9)
while (is.unsorted(x) = TRUE) {
for (pos in 1:4)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
x <- x_temp
}
while (is.unsorted(x) = TRUE) {
{for (pos in 1:4)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,3,9)
x <- c(1,7,5,3,9)
while (is.unsorted(x) = TRUE) {
{for (pos in 1:4)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9.3)
x_temp <- c(1,7,5,9,3)
x <- x_temp
x_temp[1] > x_temp[2]
x_temp <- c(1,7,5,9,3)
x <- x_temp
while (is.unsorted(x) == TRUE) {
{for (pos in 1:4)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
length(x_temp)
x_temp <- c(1,7,5,9,3)
x <- x_temp
length(x_temp)
x_temp <- c(1,7,5,9,3)
x <- x_temp
while (is.unsorted(x) == TRUE) {
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
{for (pos in 1:(length(x)-1)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9,3)
x <- x_temp
while (is.unsorted(x) == TRUE) {
while (is.unsorted(x) == TRUE) {
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
x <- x_temp
{for (pos in 1:(length(x)-1)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9,3)
x <- x_temp
while (is.unsorted(x) == TRUE) {
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
{for (pos in seq(1,length(x)-1)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
while (is.unsorted(x) == TRUE) {
{for (pos in seq(1,length(x)-1)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9,3)
x <- x_temp
while (is.unsorted(x) == TRUE) {
{for (pos in seq(1,length(x)-1)
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9,3)
x <- x_temp
while (is.unsorted(x) == TRUE) {
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9,3,22,27,6,4,8)
x <- x_temp
while (is.unsorted(x) == TRUE) {
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9,3,22,27,6,4,8)
x <- x_temp
while (is.unsorted(x) == TRUE) {
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
}
x <- x_temp
}
x_temp <- c(1,7,5,9,3,22,27,6,4,8)
x <- x_temp
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 1
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 2
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 3
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 4
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 5
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 6
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 7
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
pos = 8
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
}
x_temp <- c(1,7,5,9,3,22,27,6,4,8)
x <- x_temp
while (is.unsorted(x) == TRUE) {
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
x <- x_temp
}
}
}
x_temp <- c(1,7,5,9,3,22,27,6,4,8,22,33,1,4,5)
x <- x_temp
while (is.unsorted(x) == TRUE) {
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
x_temp[pos] <- x[pos+1]
x_temp[pos+1] <- x[pos]
x <- x_temp
}
}
}
x
sample(x)
x_temp <- c(1,7,5,9,3)
x <- x_temp
sample(x)
x_temp <- c(1,7,5,9,3)
x <- x_temp
k <- 0
while (is.unsorted(x) == TRUE) {
sample(x)
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
k <- k+1
}
}
}
x
sample(x)
x <- sample(x)
x <- sample(x)
x <- sample(x)
x_temp <- x
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
k <- k+1
}
}
while (is.unsorted(x) == TRUE) {
x <- sample(x)
x_temp <- x
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
k <- k+1
}
}
}
x
x_temp <- c(1,7,5,9,3)
x <- x_temp
k <- 0
while (is.unsorted(x) == TRUE) {
x <- sample(x)
x_temp <- x
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
k <- k+1
}
}
}
x_temp <- c(1,7,5,9,3)
x <- x_temp
k <- 0
while (is.unsorted(x) == TRUE) {
x <- sample(x)
x_temp <- x
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
k <- k+1
}
}
}
x_temp <- c(1,7,5,9,3,22,12,15,11,11,17,5,4,7)
x <- x_temp
k <- 0
while (is.unsorted(x) == TRUE) {
x <- sample(x)
x_temp <- x
{for (pos in seq(1,length(x)-1))
if (x_temp[pos] > x_temp[pos+1]){
k <- k+1
}
}
}
"A" > "B"
"A" < "B"
Le pseudo-code est souvent très utile pour répondre à ce commandement. Celui-ci agit à titre de résumer et nous permet de mieux séparer les différentes sections nécessaires dans la réalisation de notre script. N'oublions pas que de programmer, c'est avant tout résoudre des problèmes. De plus, si l'histoire nous a bien appris une chose, c'est bien qu'il vaut mieux diviser pour régner.

if (etats_prec[j] == 0){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumR[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 1){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumT[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 2){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumB[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else {
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumM[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
}
}
return(etats_prec)
}
nb_temps <- function(netape){
etats <- matrix(0, nrow = nrow(quadrats), ncol = netape)
etats[(quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0), 1] <- 1 #T
etats[(quadrats[,3] != 0 | quadrats[,9] != 0), 1] <- 2 #B
etats[((quadrats[,3] != 0 | quadrats[,9] != 0) & (quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0)), 1] <- 3 #M
# 0 signifie R
paysage <- tapply(etats[,1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = 1"),xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
for (n in 1:(netape-1)){
etats[,n+1] <- func_etats(etats[,n])
paysage <- tapply(etats[,n+1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = ", n+1) ,xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
}
return(etats)
}
########################CALCUL FINAL############################
system.time(nb_temps(100))
########################CALCUL FINAL############################
system.time(nb_temps(10))
quadrats <- read.table(file = "./quadrats.txt", header=TRUE, sep = ";") # On importe les données
head(quadrats) # On observe le début des données
nrow(quadrats) # On a 500 données
mat_trans <- read.table(file = "./matrice_transitions.txt", header = F, sep = "")
mat_trans <- as.matrix(mat_trans)
##################################################
########## Valeur initiale à spécifier ###########
##################################################
cetats <- c(2,3,1,0) # États dans l'ordre
cumB <- cumsum(mat_trans[1,]) # Pour la probabilité
cumM <- cumsum(mat_trans[2,]) # Pour la probabilité
cumT <- cumsum(mat_trans[3,]) # Pour la probabilité
cumR <- cumsum(mat_trans[4,]) # Pour la probabilité
coordx <- seq(0,180,20) # Pour le graphique
coordy <- seq(0,980,20) # Pour le graphique
################################################################
### FONCTION POUR LES ÉTATS EN FONCTION DE L'ÉTAT PRÉCÉDENT ####
################################################################
func_etats <- function(etats_prec){
for (j in 1:nrow(quadrats)){
if (etats_prec[j] == 0){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumR[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 1){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumT[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 2){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumB[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else {
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumM[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
}
}
return(etats_prec)
}
################################################################
######## FONCTION POUR LE NOMBRE DE TEMPS QU'ON CALCUL #########
################################################################
nb_temps <- function(netape){
# ÉTAT INITIAL
etats <- matrix(0, nrow = nrow(quadrats), ncol = netape)
etats[(quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0), 1] <- 1 #T
etats[(quadrats[,3] != 0 | quadrats[,9] != 0), 1] <- 2 #B
etats[((quadrats[,3] != 0 | quadrats[,9] != 0) & (quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0)), 1] <- 3 #M
# 0 signifie R
paysage <- tapply(etats[,1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = 1"),xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
for (n in 1:(netape-1)){
etats[,n+1] <- func_etats(etats[,n])
paysage <- tapply(etats[,n+1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = ", n+1) ,xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
}
return(etats)
}
########################CALCUL FINAL############################
system.time(nb_temps(10))
system.time(nb_temps(100))
n <- 1
while(etats[,n+1] != etats[,n]){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}
etats <- nb_temps(2)
n <- 1
while(etats[,n+1] != etats[,n]){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}
n <- 1
while(setequal(etats[,n+1],etats[,n]) == FALSE){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}
#######################################
##### Importation/Visualisation des données ######
##################################################
quadrats <- read.table(file = "./quadrats.txt", header=TRUE, sep = ";") # On importe les données
head(quadrats) # On observe le début des données
nrow(quadrats) # On a 500 données
mat_trans <- read.table(file = "./matrice_transitions.txt", header = F, sep = "")
mat_trans <- as.matrix(mat_trans)
##################################################
########## Valeur initiale à spécifier ###########
##################################################
cetats <- c(2,3,1,0) # États dans l'ordre
cumB <- cumsum(mat_trans[1,]) # Pour la probabilité
cumM <- cumsum(mat_trans[2,]) # Pour la probabilité
cumT <- cumsum(mat_trans[3,]) # Pour la probabilité
cumR <- cumsum(mat_trans[4,]) # Pour la probabilité
coordx <- seq(0,180,20) # Pour le graphique
coordy <- seq(0,980,20) # Pour le graphique
################################################################
### FONCTION POUR LES ÉTATS EN FONCTION DE L'ÉTAT PRÉCÉDENT ####
################################################################
func_etats <- function(etats_prec){
for (j in 1:nrow(quadrats)){
if (etats_prec[j] == 0){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumR[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 1){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumT[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 2){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumB[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else {
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumM[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
}
}
return(etats_prec)
}
################################################################
######## FONCTION POUR LE NOMBRE DE TEMPS QU'ON CALCUL #########
################################################################
nb_temps <- function(netape){
# ÉTAT INITIAL
etats <- matrix(0, nrow = nrow(quadrats), ncol = netape)
etats[(quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0), 1] <- 1 #T
etats[(quadrats[,3] != 0 | quadrats[,9] != 0), 1] <- 2 #B
etats[((quadrats[,3] != 0 | quadrats[,9] != 0) & (quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0)), 1] <- 3 #M
# 0 signifie R
paysage <- tapply(etats[,1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = 1"),xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
for (n in 1:(netape-1)){
etats[,n+1] <- func_etats(etats[,n])
paysage <- tapply(etats[,n+1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = ", n+1) ,xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
}
return(etats)
}
etats <- nb_temps(2)
etats
nb_temps <- function(netape){
# ÉTAT INITIAL
etats <- matrix(0, nrow = nrow(quadrats), ncol = 10000)
etats[(quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0), 1] <- 1 #T
etats[(quadrats[,3] != 0 | quadrats[,9] != 0), 1] <- 2 #B
etats[((quadrats[,3] != 0 | quadrats[,9] != 0) & (quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0)), 1] <- 3 #M
# 0 signifie R
paysage <- tapply(etats[,1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = 1"),xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
for (n in 1:(netape-1)){
etats[,n+1] <- func_etats(etats[,n])
paysage <- tapply(etats[,n+1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = ", n+1) ,xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
}
return(etats)
}
etats <- nb_temps(2)
etats
View(etats)
n <- 1
while(setequal(etats[,n+1],etats[,n]) == FALSE){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}
setequal(etats[,2],etats[,1])
etats[,1]
etats[,2]
setequal((etats[,2],etats[,1]))
setequal((etats[,2],etats[,1]))
setequal((etats[,2]),(etats[,1])))
setequal((etats[,2]),(etats[,1]))
identical((etats[,2]),(etats[,1]))
while(identical(etats[,n+1],etats[,n]) == FALSE){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}
etats <- nb_temps(2)
n <- 1
while(identical(etats[,n+1],etats[,n]) == FALSE){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}
###### EXERCICE FINAL ##########
##################################################
##### Importation/Visualisation des données ######
##################################################
quadrats <- read.table(file = "./quadrats.txt", header=TRUE, sep = ";") # On importe les données
head(quadrats) # On observe le début des données
nrow(quadrats) # On a 500 données
mat_trans <- read.table(file = "./matrice_transitions.txt", header = F, sep = "")
mat_trans <- as.matrix(mat_trans)
##################################################
########## Valeur initiale à spécifier ###########
##################################################
cetats <- c(2,3,1,0) # États dans l'ordre
cumB <- cumsum(mat_trans[1,]) # Pour la probabilité
cumM <- cumsum(mat_trans[2,]) # Pour la probabilité
cumT <- cumsum(mat_trans[3,]) # Pour la probabilité
cumR <- cumsum(mat_trans[4,]) # Pour la probabilité
coordx <- seq(0,180,20) # Pour le graphique
coordy <- seq(0,980,20) # Pour le graphique
################################################################
### FONCTION POUR LES ÉTATS EN FONCTION DE L'ÉTAT PRÉCÉDENT ####
################################################################
func_etats <- function(etats_prec){
for (j in 1:nrow(quadrats)){
if (etats_prec[j] == 0){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumR[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 1){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumT[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 2){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumB[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else {
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumM[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
}
}
return(etats_prec)
}
################################################################
######## FONCTION POUR LE NOMBRE DE TEMPS QU'ON CALCUL #########
################################################################
nb_temps <- function(netape){
# ÉTAT INITIAL
etats <- matrix(0, nrow = nrow(quadrats), ncol = 10000)
etats[(quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0), 1] <- 1 #T
etats[(quadrats[,3] != 0 | quadrats[,9] != 0), 1] <- 2 #B
etats[((quadrats[,3] != 0 | quadrats[,9] != 0) & (quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0)), 1] <- 3 #M
# 0 signifie R
paysage <- tapply(etats[,1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = 1"),xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
for (n in 1:(netape-1)){
etats[,n+1] <- func_etats(etats[,n])
paysage <- tapply(etats[,n+1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = ", n+1) ,xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
}
return(etats)
}
etats <- nb_temps(2)
n <- 1
while(identical(etats[,n+1],etats[,n]) == FALSE){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}
system.time(nb_temps(2700))
###### EXERCICE FINAL ##########
##################################################
##### Importation/Visualisation des données ######
##################################################
quadrats <- read.table(file = "./quadrats.txt", header=TRUE, sep = ";") # On importe les données
head(quadrats) # On observe le début des données
nrow(quadrats) # On a 500 données
mat_trans <- read.table(file = "./matrice_transitions.txt", header = F, sep = "")
mat_trans <- as.matrix(mat_trans)
##################################################
########## Valeur initiale à spécifier ###########
##################################################
cetats <- c(2,3,1,0) # États dans l'ordre
cumB <- cumsum(mat_trans[1,]) # Pour la probabilité
cumM <- cumsum(mat_trans[2,]) # Pour la probabilité
cumT <- cumsum(mat_trans[3,]) # Pour la probabilité
cumR <- cumsum(mat_trans[4,]) # Pour la probabilité
coordx <- seq(0,180,20) # Pour le graphique
coordy <- seq(0,980,20) # Pour le graphique
################################################################
### FONCTION POUR LES ÉTATS EN FONCTION DE L'ÉTAT PRÉCÉDENT ####
################################################################
func_etats <- function(etats_prec){
for (j in 1:nrow(quadrats)){
if (etats_prec[j] == 0){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumR[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 1){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumT[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else if (etats_prec[j] == 2){
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumB[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
} else {
i <- 1; plus_petit = FALSE
while(plus_petit == FALSE){
if (runif(1) < cumM[i]){
etats_prec[j] <- cetats[i]
plus_petit <- TRUE
} else {
i <- i + 1
}
}
}
}
return(etats_prec)
}
################################################################
######## FONCTION POUR LE NOMBRE DE TEMPS QU'ON CALCUL #########
################################################################
nb_temps <- function(netape){
# ÉTAT INITIAL
etats <- matrix(0, nrow = nrow(quadrats), ncol = netape)
etats[(quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0), 1] <- 1 #T
etats[(quadrats[,3] != 0 | quadrats[,9] != 0), 1] <- 2 #B
etats[((quadrats[,3] != 0 | quadrats[,9] != 0) & (quadrats[,5] != 0 | quadrats[,6] != 0 | quadrats[,8] != 0)), 1] <- 3 #M
# 0 signifie R
paysage <- tapply(etats[,1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = 1"),xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
for (n in 1:(netape-1)){
etats[,n+1] <- func_etats(etats[,n])
paysage <- tapply(etats[,n+1],INDEX = quadrats[,c(1:2)],sum)
par(mar = c(4,4,3,0.5))
image(x=coordx,y=coordy,z=paysage, main = paste("Temps = ", n+1) ,xlab=NULL,ylab=NULL,
col=c("black","orange","darkcyan","palegreen3"))
}
return(etats)
}
# Quand est-ce que ça ne change pas pour la première fois?
etats <- nb_temps(2)
etats
cbind(etats,matrix(0, nrow = nrow(quadrats), ncol = (10000-2)))
View(etats)
etats <- cbind(etats,matrix(0, nrow = nrow(quadrats), ncol = (10000-2)))
View(etats)
n <- 1
while(identical(etats[,n+1],etats[,n]) == FALSE){
etats[,n+2] <- func_etats(etats[,n+1])
n <- n + 1
}

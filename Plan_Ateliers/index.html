<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>: Introduction à la programmation scientifique</title>
    <meta charset="utf-8" />
    <meta name="author" content="Antoine Bergeron" />
    <link href="assets/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="assets/remark-css-0.0.1/hygge.css" rel="stylesheet" />
    <link rel="stylesheet" href="../Ateliers_ALEA.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: title-slide, middle

&lt;style type="text/css"&gt;
  .title-slide {
    background-image: url('assets/img/Coding.png');
    background-color: #23373B;
    background-size: contain;
    border: 0px;
    background-position: 600px 0;
    line-height: 1;
  }
&lt;/style&gt;

# Bienvenue au plan des ateliers!

&lt;hr width="65%" align="left" size="0.3" color="orange"&gt;&lt;/hr&gt;

### Introduction à la programmation scientifique et au langage R

&lt;hr width="65%" align="left" size="0.3" color="orange" style="margin-bottom:40px;" alt="@Martin Sanchez"&gt;&lt;/hr&gt;

.instructors[
  ***ALÉA R*** - Antoine Bergeron
]

&lt;img src="assets/img/Rlogo.png" width="8%" style="margin-top:20px;"&gt;&lt;/img&gt;

---

# Présentation générale

Cette introduction à la programmation scientifique se fera sous forme de différents ateliers. Plusieurs courtes capsules nous permettront de passer à travers chacun des ateliers. 

Les connaissances requises pour la programmation scientifique sont
minimales, l'apprentissage portera davantage sur l'acquisition de
compétences et le développement de capacités à la résolution de problèmes.

Le sujet des capsules portera sur des notions de base de
programmation, entre-coupées d'exercices spécifiques
destinés à pratiquer les éléments enseignés. L'atelier se terminera avec
la réalisation d'un exercice intégrateur à compléter à la maison.

L'ensemble du matériel du cours sera disponible sur un dépôt Git à l'adresse :
https://github.com/AntoineBergeron/Ateliers_ALEA

---

# Présentation: détails spécifiques

Un nombre total de 3 ateliers sont proposés. 

L'atelier 1 propose une ouverture sur la programmation en général (les bonnes pratiques en programmation, par exemple). Les grands concepts de cet atelier sont: le pseudo-code, les types de valeur et d'objets ainsi que l'interaction avec ses fichiers.

L'atelier 2 comporte une première partie sur les calculs de base en R, qui nous sera utilise dans l'écriture de fonctions que nous verrons dans la deuxième partie de l'atelier.

L'atelier 3 concerne les algorithmes. On y retrouve les concepts de boucles, d'indexation, les expressions conditionnelles et quelques explications sur l'optimisation des scripts.

---

# Marche à suivre

Deux méthodes d'apprentissage vous sont proposés:

1. En visionnant les capsules de chaque ateliers;
2. En parcourant l'atelier à l'aide de la présentation HTML;

Un mixte des deux méthodes peut être une solution envisageable.

Par contre, gardez en tête que les capsules possèdent beaucoup plus d'informations et que certaines diapositives ne veulent rien dire sans l'ajout des commentaires orales sur les vidéos.

---

# Exercices


À travers les différentes capsules que vous allez parcourir, une multitude d'exercices vous seront proposés. Dans un monde idéal, la marche à suivre serait alors de:

1. Mettre la vidéo sur pause;
2. Résoudre l'exercice;
3. Continuer la vidéo et confirmer votre réponse avec la solution;

Comme dans n'importe quoi, vos qualités de programmeur auront un lien très étroit avec le temps passé à essayer par vous même les exercices. 

Pour sa part, l'exercice récapitulatif de fin d'atelier n'aura pas de solutionnaire et sera utilisé en guise de *devoir*.


---

# Objectif général

Au terme de cet atelier, vous serez en mesure de conceptualiser un problème qui requiert de la programmation scientifique et de réaliser des tâches courantes de programmation.


---

# Objectifs spécifiques

1. Charger des données et exporter des résultats d'analyse au moyen du
    logiciel R;
2. Conceptualiser un problème au moyen de pseudo-code;
3. Manipuler des données;
4. Rédiger des fonctions;
5. Programmer des algorithmes afin de réaliser des tâches complexes,
    incluant des boucles et des énoncés conditionnels;
6. Réaliser des simulations de Monte Carlo;

---
# Contenu

1. Introduction et bonnes pratiques de programmation (atelier 1)
2. Interagir avec R (atelier 1)
3. Les fonctions (atelier 2)
4. Algorithmique I: boucles et conditions (atelier 3)
5. Algorithmique II: simulations de Monte Carlo (atelier 3)

---

# Ce que le cours n'est pas ...

1. Des recettes
2. Un catalogue de fonctions R
3. Un cours de statistiques
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "monokai",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

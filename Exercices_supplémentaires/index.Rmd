---
title: ": Introduction à la programmation scientifique"
author: "Antoine Bergeron"
date: "A2020"
output:
  xaringan::moon_reader:
    css: [default, ../Ateliers_ALEA.css, "hygge"]
    lib_dir: assets
    seal: false
    nature:
      highlightStyle: monokai
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "../macros.js"
---

class: title-slide, middle

<style type="text/css">
  .title-slide {
    background-image: url('assets/img/Coding.png');
    background-color: #23373B;
    background-size: contain;
    border: 0px;
    background-position: 600px 0;
    line-height: 1;
  }
</style>

# Bienvenue aux exercices supplémentaires

<hr width="65%" align="left" size="0.3" color="orange"></hr>

## Atelier 1, 2 et 3. 

<hr width="65%" align="left" size="0.3" color="orange" style="margin-bottom:40px;" alt="@Martin Sanchez"></hr>

.instructors[
  ***ALÉA R*** - Antoine Bergeron
]

<img src="assets/img/Rlogo.png" width="8%" style="margin-top:20px;"></img>


---
class: inverse, middle, center

# Exercices supplémentaires de l'atelier 1
<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>


---

# Exemple 1

Supposons que l'on cherche à calculer:


$$ \dfrac{(5x+2) \cdot 2y}{z+9} $$

avec $x = 1$, $y = 3$ et $z = 3$.

---

# Exemple 1 (suite)

```
x <- 1
y <- 3
z <- 3


res1 <- 5*x+2*2*y/z+9
res2 <- 5*x+2*2*y/(z+9)
res3 <- 5*(x+2*2*y/z)+9
res4 <- ((5*x+2)*2*y)/(z+9)
res5 <- ((5*x+2)*2*y)/z+9

res1 = 18
res2 = 6
res3 = 34
res4 = 3.5
res5 = 23


```
Mais, quelle réponse est la bonne? 


---
class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 1 (solution)

La solution est belle et bien la valeur de res4, soit 3.5.

On peut voir le numérateur et le dénominateur comme deux termes indépendants:  [(5x+2)*2y] et [z+9].

Le terme du numérateur nous indique clairement que l'ensemble du terme (5x+2) doit être multiplié par 2y, d'où ((5x+2)*2y).


Donc, $(5x+2) = (5*1+2) = 7$. 

Et, $2y = 2*3 = 6$.

D'où, $((5x+2)*2y) = ((7)*6) = 42$.

De plus, $(z+9) = (3+9) = 12$.

Enfin, $((5x+2)*2y)/(z+9) = (42)/(12) = 3.5$.

Notons que la fonction $(5*x+2)*2*y/(z+9)$ aurait aussi fonctionné.

---

# Exemple 2

Lors d'un entraînement de hockey, on demande au gardien de but de réaliser 10 arrêts avant de pouvoir quitter la patinoire.
Ainsi, tant qu'il n'aura pas fait 10 arrêts, ce dernier doit continuer l'entraînement.
Écrivez le pseudo-code relié à cette situation. 

Pour la ligne correspondante au "calcul de si l'arrêt a été effectué", vous pouvez utiliser celle-ci:
*Calcul de (ARRET <- TRUE) ou (ARRET <- FALSE) 

*Nous verrons des exemples à l'atelier 3 sur comment calculer aléatoirement un évènement comme celui-ci à l'aide de probabilité.

---
class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 2 (solution)

```
Nb_arret <- 0  # Le gardien débute avec aucun arrêt

                                  # Tant que le nombre d'arrêt est plus petit que 10
While(Nb_arret < 10){                              # On "observe" si le gardien fait
Calcul de (ARRET <- TRUE) ou (ARRET <- FALSE)       # un arrêt ou non
   if(ARRET == TRUE){                               # S'il a fait un arrêt,
     Nb_arret <- Nb_arret + 1                # Alors le nombre d'arrêt augmente de 1
   }                                # Pas besoin de else (S'il n'a pas fait d'arrêt, 
}                             # alors on recommence la boucle while tout simplement)
```

---

# Exemple 3

<text style="font-size:Large;">

Béatrice et Claude vont à l'Université de Sherbrooke et sont dans le même programme. À la suite de deux sessions, Béatrice est d'une constance incroyable. Pour ces 10 cours, elle a obtenu une moyenne de 70 exactement. Pour sa part, Claude a obtenu des moyennes plus variables. Celles-ci sont représentées dans le vecteur suivant:

C = (60.70,80,90,60,70,80,90,80,50)

Cependant, Claude remarque qu'il a inscrit ses notes à l'envers dans le vecteur. Ainsi, la première position (60) représente sa moyenne au cours #10, la deuxième position (70) représente sa moyenne au cours #9, et ainsi de suite. 

À l'aide d'un vecteur B (celui des notes de Béatrice) et du vecteur C (on doit utiliser le vecteur C, et non pas récrire le vecteur C à l'envers!!!), écrivez le pseudo-code qui permettrait de déterminer qui entre Béatrice et Claude a obtenu le meilleur résultat à chaque examen. On aimerait afficher à l'écran que Claude ou Béatrice a obtenu la meilleure note dans un tel cas, et inscrire que les notes sont semblables si celles-ci sont égales.

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 3 (solution)

<text style="font-size:footnotesize;">

```
B <- c(70,70,70,70,70,70,70,70,70,70) 
C <- c(60.70,80,90,60,70,80,90,80,50)

FOR POS in 1:10  
  IF(B[POS] > C[11-POS]){ 
    PRINT("Béatrice a obtenu la meilleure note")
  } ELSEIF (B[POS] < C[11-POS]){ 
    PRINT("Claude a obtenu la meilleure note") 
  } ELSE { 
    PRINT("Les notes sont semblables")
  }
  ENDIF
END FOR
```

Remarquons que l'on compare la position POS du vecteur B avec la position 11-POS du vecteur C. Ainsi, en ordre, de POS=1 à POS=10, on compare les positions, sous forme de couple, suivantes: (1,10), (2,9), (3,8), ... , (10,1). La comparaison est donc adéquate.

---

# Exemple 3 (solution)

<text style="font-size:footnotesize;">


 - Cours dans l'ordre (1,2,3,...)
 - Cours à l'envers (10,9,8,...) d'où 
 - position 10 = 1er cours, position 9 = 2e cours
 - position 8 = 3e cours, position 7 = 4e cours, etc.
   
   
 - Pour chacune des 10 positions du vecteur (les 10 cours)
   - si la valeur en position POS pour Béatrice (Cours POS)
   - est plus grande que la valeur en position 11 - POS
   - pour Claude (Cours POS)
   - Alors, c'est que Béatrice a la meilleure note
   - Si c'est le contraire (seul le signe d'inégalité change)
   - Alors, c'est que Claude a la meilleure note
   - Sinon, c'est qu'ils ont la même note!
   - D'où, les notes sont semblables
   
---

# Exemple 4

La fonction rank() sur R prend un vecteur en argument et retourne le rang des valeurs dans un nouveau vecteur de même longueur. Par exemple,

```{r}
vec <- c(24,52,11,7,34,77,47,1,96,45)
rank(vec)
```
   
Écrivez un pseudo-code, à l'aide de boucles et d'expressions conditionnelles, pouvant remplacer la fonction rank(). Pour vous faciliter la tâche, supposez que les valeurs du vecteur sont toutes différentes.

*Indice:* Pour chacune des positions du vecteur que l'on souhaite créer, on cherche à comparer la position identique du vecteur "vec" avec toutes les autres valeurs. Lorsque cette valeur est plus grande qu'une autre valeur, alors c'est que son rang doit augmenter.

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 4 (solution)

```
vec <- c(24,52,11,7,34,77,47,1,96,45)
vec_rang <- rep(1,10)   # création d'un vecteur (1,1,...,1)

FOR i in 1:10
  FOR j in 1:10
    IF(vec[i] > vec[j])
      vec_rang[i] <- vec_rang[i] + 1
    ENDIF
  END FOR
END FOR
```

Dans les exercices supplémentaires de l'atelier 2, nous créerons une fonction en se basant sur ce pseudo-code.

---

# Exemple 5

Rémi est à la recherche du crystal enchanté.

<div style='text-align:center;'>
<img src="assets/img/remi.PNG" height="300px"></img>
</div>

Sa route le mêne au labyrinthe des Luncredi, illustré à la diapositive suivante.

---

# Exemple 5 (suite)

Heureusement, Rémi avait son cellulaire pour vous contacter. Vous survolez présentement le labyrinthe en hélicoptère. 

Déterminez la route que Rémi doit prendre pour aller du début à la fin du labyrinthe.

<div style='text-align:center;'>
<img src="assets/img/labyrintheNONRES.PNG" height="300px"></img>
</div>

---

# Exemple 5 (suite)

À vue d'oeil, le chemin a prendre est unique et est indiqué en blanc.

<div style='text-align:center;'>
<img src="assets/img/labyrintheRES.PNG" height="300px"></img>
</div>

---

# Exemple 5 (suite)

Il est d'ailleurs possible de séparer la route à emprunter en 4 sections:

<div style='text-align:center;'>
<img src="assets/img/labyrintheEXP.PNG" height="300px"></img>
</div>

---

# Exemple 5 (suite)

Section 1: <div style='text-align:center;'>
<img src="assets/img/region1.PNG" height="70px"></img>
</div>

Section 2: <div style='text-align:center;'>
<img src="assets/img/region2.PNG" height="70px"></img>
</div>

Section 3: <div style='text-align:center;'>
<img src="assets/img/region3.PNG" height="70px"></img>
</div>

Section 4: <div style='text-align:center;'>
La section courbe est d'une longueur de 110 mètres
</div>

---

# Exemple 5 (suite)

Déterminez le pseudo code a envoyer à Rémi afin de lui permettre de se rendre à la fin du labyrinthe. On peut penser à des étapes dans le style suivant:

- Avancer de X mètres
- Tourner à (gauche/droite)

*Notons que Rémi regarde initialement vers la droite. Il est donc déjà prêt à emprunter le premier chemin.

---


class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 5 (solution)

Section 1:

.pull-left[
Une indication à la fois:

```
Avancer de 50 mètres
Tourner à droite
Avancer de 30 mètres
Tourner à gauche
Avancer de 50 mètres
Tourner à droite
Avancer de 30 mètres
Tourner à gauche
Avancer de 50 mètres
Tourner à droite
```

</div>
]

.pull-right[
À l'aide d'une boucle:

```
FOR mouvement in 1:2
   Avancer de 50 mètres
   Tourner à droite
   Avancer de 30 mètres
   Tourner à gauche
ENDFOR

Avancer de 50 mètres
Tourner à droite
```

</div>
]

---

# Exemple 5 (solution: suite)

Section 2:

.pull-left[
Une indication à la fois:

```
Avancer de 70 mètres
Tourner à gauche
Avancer de 60 mètres
Tourner à droite
Avancer de 70 mètres
Tourner à gauche
Avancer de 60 mètres
Tourner à droite
Avancer de 70 mètres
Tourner à gauche
```

</div>
]

.pull-right[
À l'aide d'une boucle:

```
FOR mouvement in 1:2
   Avancer de 70 mètres
   Tourner à gauche
   Avancer de 60 mètres
   Tourner à droite
ENDFOR

Avancer de 70 mètres
Tourner à gauche
```

</div>
]

---

# Exemple 5 (solution: suite)

Section 3:

.pull-left[
Une indication à la fois:

```
Avancer de 70 mètres
Tourner à gauche
Avancer de 70 mètres
Tourner à droite
Avancer de 70 mètres
Tourner à gauche
Avancer de 70 mètres
Tourner à droite
Avancer de 70 mètres
Tourner à gauche
```

</div>
]

.pull-right[
À l'aide d'une boucle:

```
FOR mouvement in 1:2
   Avancer de 70 mètres
   Tourner à gauche
   Avancer de 70 mètres
   Tourner à droite
ENDFOR

Avancer de 70 mètres
Tourner à gauche
```

</div>
]

---

# Exemple 5 (solution: suite)

Section 4:

```
Avancer de 110 mètres dans la courbe
```

---

# Exemple 5 (solution: suite)

Total:

.pull-left[

```
# Section 1
FOR mouvement in 1:2
   Avancer de 50 mètres
   Tourner à droite
   Avancer de 30 mètres
   Tourner à gauche
ENDFOR

Avancer de 50 mètres
Tourner à droite

# Section 2
FOR mouvement in 1:2
   Avancer de 70 mètres
   Tourner à gauche
   Avancer de 60 mètres
   Tourner à droite
ENDFOR
```

</div>
]

.pull-right[

```
# Section 2 (suite)
Avancer de 70 mètres
Tourner à gauche

# Section 3
FOR mouvement in 1:2
   Avancer de 70 mètres
   Tourner à gauche
   Avancer de 70 mètres
   Tourner à droite
ENDFOR

Avancer de 70 mètres
Tourner à gauche

# Section 4
Avancer de 110 mètres dans la courbe
```

</div>
]


---
class: inverse, middle, center

# Exercices supplémentaires de l'atelier 2
<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>


---

# Exemple 1

Dans le cadre de la collation des grades à l'UdeS, on souhaite imprimer une phrase afin de la déposer sur le siège de chaque étudiant gradué. Les étudiants remplissent alors un formulaire en ligne et doivent indiquer leur nom, leur champ d'études, la durée de leurs études et leur âge à l'instant présent.


À l'aide de ces informations, on aimerait créer une fonction qui permettra, en fonction des informations de chaque finissant, d'écrire ceci:

```
NOM, a réalisé des études en SUJET, d'une durée approximative de ANS D'ÉTUDE ans. 
NOM termine ses études à l'âge de AGE ans.
```

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 1 (solution)

```{r}
ecrire.phrase <- function(nom,age,annee.etude,sujet){
  cat(nom, "a réalisé ses études en", sujet, ", d'une durée approximative de", round(annee.etude), "ans. \n")
  cat(nom, "termine ses études à l'âge de", age, "ans.")
}


ecrire.phrase("Rolland","19",1.7,"géographie")
ecrire.phrase("Linda", "47", 2.8, "comptabilité")
ecrire.phrase("M. Kombucha", "31", 8.6, "médecine")
```


---

# Exemple 2

Lors de l'exemple 4 des exercices supplémentaires de l'atelier 1, nous avons défini un pseudo-code pour remplacer la fonction rank(). Pour cet exercice, on vous demande de coder le pseudo-code sous forme d'une fonction qui prend en argument le vecteur, et qui retourne le vecteur de rang, sans utiliser la fonction rank() bien sûr.

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 2 (solution)

```{r}
func_rang <- function(vec){
  vec_rang <- rep(1,length(vec))

  for (i in (1:length(vec))){
    for (j in (1:length(vec))){
      if(vec[i] > vec[j]){
        vec_rang[i] <- vec_rang[i] + 1
      }
    }
  }
  return(vec_rang)
}
```

```{r}
vec1 <- c(24,52,11,7,34,77,47,1,96,45)
func_rang(vec1)
rank(vec1)
```

---


# Exemple 3

.pull-left[
<div style='text-align:center;'>
On cherche ici à trouver la longueur d'un vecteur. Effectivement, lorsque le vecteur augmente sur l'axe des abscisses (axe des x) et sur l'axe des ordonnées (axe des y), la longueur totale du vecteur ne se calcule pas aussi simplement que "distance en X + distance en Y". À droite, l'illustration définit bien le calcul général que l'on doit appliquer.
</div>
]

.pull-right[
<div style='text-align:center;'>
<img src="assets/img/vecteurgif.gif" height="300px"></img>
</div>
]

---

# Exemple 3 (suite)

La formule se généralise lorsque le vecteur n'a pas seulement deux éléments.

Par exemple:

Soit le vecteur (x,y), alors la longueur de celui-ci est donnée par $\sqrt{x^2 + y^2}$.

Soit le vecteur (x,y,z), alors la longueur de celui-ci est donnée par $\sqrt{x^2 + y^2 + z^2}$.

Créez une fonction qui permettra de calculer, peu importe le vecteur entré en argument, la longueur de ce dernier.

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 3 (solution)


```{r}
calcul.norme <- function(vecteur){ # Argument est le vecteur
  sqrt(sum(vecteur^2)) # On fait la racine carrée de "la somme des éléments au carré"
}

calcul.norme(c(6,4)) # Notre vecteur illustré à la diapositive précédente
calcul.norme(c(1,2,3,4,5,6,7,6,5,4,3,2,1))
calcul.norme(c(2,2,2,2))
```

---


# Exemple 4

Comme vous avez pu le remarquer, une matrice est un tableau rectangulaire comportant des lignes et des colonnes. Lorsqu'une matrice comporte autant de lignes que de colonnes, on dit alors que la matrice est carrée. Ce type de matrice possède plusieurs propriétés supplémentaires. Effectivement, le **déterminant** d'une matrice peut seulement être calculé si cette même matrice est carrée. 

Dans cet exercice, nous nous intéresserons à calculer le déterminant d'une matrice 2x2 (donc quatre éléments). Pour une matrice 

$$A = \begin{bmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}
\end{bmatrix}$$

alors on note $det(A) = a_{11}*a_{22} - a_{21}*a_{12}$.

Créez une fonction qui calculera le déterminant d'une matrice 2x2. Dans le cas d'une matrice d'une autre dimension, on souhaite que la fonction retourne un message d'erreur indiquant que "La dimension de la matrice n'est pas 2x2".

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 4 (solution)


```{r}
det.2x2 <- function(matrice){
  if((((dim(matrice))[1] != (c(2,2))[1])) || (((dim(matrice))[2] != (c(2,2))[2]))){
    stop("La dimension de la matrice n'est pas 2x2")
  }
  mat <- matrice[1,1]*matrice[2,2] - matrice[1,2]*matrice[2,1]
  return(mat)
}
```

```{r}

mat1 <- matrix(c(1,2,3,4), nrow = 2, ncol = 2)
mat1
det.2x2(mat1)
```

---

# Exemple 4 (solution: suite)

```{r, error=TRUE}
mat2 <- matrix(c(1,7,2,34), nrow = 2, ncol = 2)
mat2
det.2x2(mat2)

mat3 <- matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3)
mat3
det.2x2(mat3)
```


---

# Exemple 5

Vous êtes présentement en train de consulter l'exemple 5 des exercices supplémentaires de l'atelier 2. 

Vous voyez! J'ai deviné ce que vous faisiez à l'instant présent. Ce n'est pas mon seul et unique tour de mathémagie!

- Prenez la pointure de vos souliers (arrondie à l'entier le plus près)
- Multipliez cette pointure par 5
- Ajoutez 50 à ce résultat
- Multipliez par 20 le nouveau résultat
- Ajoutez maintenant 1030 au résultat
- Finalement, veuillez soustraire votre année de naissance

TADAM! 

Avant de comprendre ce qu'est le résultat, créons d'abord la fonction qui permet d'arriver à ce résultat, en fonction de la pointure et de l'année de naissance d'un individu quelconque.

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 5 (solution)

```{r}
pointure.age <- function(pointure, annee_naissance){
  etape1 <- pointure * 5
  etape2 <- etape1 + 50
  etape3 <- etape2 * 20
  etape4 <- etape3 + 1030
  etape5 <- etape4 - annee_naissance
  return(etape5)
}
```

```{r}
pointure.age(11,1998)
pointure.age(5,2018)
```

Les deux derniers chiffres représentent l'âge que vous aurez en 2030, alors que les deux premiers (ou le premier) représentent votre pointure de soulier.

INCROYABLE!

---

# Exemple 6

Reprenons l'exemple 5 des exercices supplémentaires de l'atelier 1. Remarquons d'abord que les sections 3 et 4 ont été modifiées. 

<div style='text-align:center;'>
<img src="assets/img/LabModif.PNG" height="300px"></img>
</div>

---

# Exemple 6 (suite)

Le pseudo-code associé serait alors le suivant:

.pull-left[

```
# Section 1
FOR mouvement in 1:2
   Avancer de 50 mètres
   Tourner à droite
   Avancer de 30 mètres
   Tourner à gauche
ENDFOR

Avancer de 50 mètres
Tourner à droite

# Section 2
FOR mouvement in 1:2
   Avancer de 70 mètres
   Tourner à gauche
   Avancer de 60 mètres
   Tourner à droite
ENDFOR
```

</div>
]

.pull-right[

```
# Section 2 (suite)
Avancer de 70 mètres
Tourner à gauche

# Section 3
FOR mouvement in 1:3
   Avancer de 70 mètres
   Tourner à gauche
   Avancer de 70 mètres
   Tourner à droite
ENDFOR

Avancer de 70 mètres
Tourner à gauche

# Section 4
Avancer de 130 mètres jusqu'à l'arrivée
```

</div>
]


---

# Exemple 6 (suite)

Dans le fichier [DeplacementRemi.R](./donnees/DeplacementRemi.R), la fonction permettant de déterminer l'emplacement (la coordonnée x et y du plan cartésien) après chaque déplacement de Rémi y est écrite. L'objet ***section1*** nous renvoie une matrice des positions empruntées par Rémi.

Notons que Rémi débute à la coordonnée (0,0), et qu'il regarde déjà en direction du chemin qu'il doit prendre. (De haut, il regarde vers la droite)

Déterminez l'ensemble des coordonnées empruntées par Rémi lors de la section 2 et 3.

À l'aide de l'information supplémentaire des prochaines diapositives, déterminez en quelle coordonnée Rémi terminera sa route.

Finalement, créez une matrice finale comportant l'ensemble des coordonnées empruntées par Rémi au cours de la section 1, 2, 3 et 4.

---

# Exemple 6 (suite)

Les arguments de cette fonction sont définis comme suit:

- posXinit: Position initiale de Rémi en x.
- posYinit: Position initiale de Rémi en y.
- directionRemi: Dans le plan cartésien, vers quelle direction doit se diriger Rémi? ("droite", "haut", "gauche", "bas")
- distance1: Lors du premier mouvement de Rémi, combien de mètres doit-il avancer?
- distance2: Lors du deuxième mouvement de Rémi, combien de mètres doit-il avancer?
- changementdirection1: Entre le premier et le deuxième mouvement, quel sera le changement de direction de Rémi? ("droite", "gauche")
- nbmouvement: Combien de fois Rémi fera le mouvement répétitif semblable à un L?
   
---

# Exemple 6 (suite)

Le mouvement en L est défini comme suit:

<div style='text-align:center;'>
<img src="assets/img/mouvement.PNG" height="200px"></img>
</div>

Bien sûr, ce mouvement est valide dans tout les sens:

<div style='text-align:center;'>
<img src="assets/img/mouvementL.PNG" height="150px"></img>
</div>

---

# Exemple 6 (suite)

La section 4 n'est pas un mouvement horizontale ou verticale. Cependant, on peut exprimer le chemin à prendre comme l'hypothénuse du triangle rectangle suivant. 

<div style='text-align:center;'>
<img src="assets/img/nouvregion4.PNG" height="200px"></img>
</div>

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>

---

# Exemple 6 (solution)

D'abord, on compile la fonction *mouvement*.

```{r, eval = FALSE}
mouvement <- function(posXinit,posYinit,directionRemi,distance1,distance2,changementdirection1,nbmouvement){
  xy <- matrix(0, nrow = 2*nbmouvement+2, ncol = 2)  # Création d'une matrice des coordonnées (x,y)
  xy[1,] <- c(posXinit,posYinit)  # Position initiale dans le plan cartésien
  
  # Si Rémi regarde à (gauche/haut/droite/bas), alors l'angle doit être de...
  if(directionRemi == "gauche"){
    angle <- 3*pi/2
  } else if(directionRemi == "droite"){
    angle <- pi/2
  } else if(directionRemi == "haut"){
    angle <- 0
  } else if(directionRemi == "bas"){
    angle <- pi
  }
  
  # Si Rémi doit tourner à (droite/gauche) au premier tournant, alors l'angle sera modifier
  if(changementdirection1 == "droite"){
    angle2 <- pi/2
  } else if(changementdirection1 == "gauche"){
    angle2 <- -pi/2
  }
  
# Suite à la diapositive suivante
```

---

# Exemple 6 (solution: suite)

```{r, eval = FALSE}
 # Suite de la fonction mouvement
 # Pour chaque mouvement de style "L", on calcule la coordonnée de Rémi au creux et à la fin du "L"
  for (i in 1:nbmouvement){
    xy[2*i,] <- c(xy[2*i-1,1] + sin(angle)*distance1, xy[2*i-1,2] + cos(angle)*distance1)
    xy[2*i+1,] <- c(xy[2*i,1] + sin(angle + angle2)*distance2, xy[2*i,2] + cos(angle + angle2)*distance2)
  }
  
  # On ajoute la dernière ligne droite nécessaire
  xy[2*nbmouvement+2,] <- c(xy[2*nbmouvement+1,1] + sin(angle)*distance1, xy[2*nbmouvement+1,2] + cos(angle)*distance1)
  return(xy)
}
```

```{r, echo=FALSE}
mouvement <- function(posXinit,posYinit,directionRemi,distance1,distance2,changementdirection1,nbmouvement){
  xy <- matrix(0, nrow = 2*nbmouvement+2, ncol = 2)  # Création d'une matrice des coordonnées (x,y)
  xy[1,] <- c(posXinit,posYinit)  # Position initiale dans le plan cartésien
  
  # Si Rémi regarde à (gauche/haut/droite/bas), alors l'angle doit être de...
  if(directionRemi == "gauche"){
    angle <- 3*pi/2
  } else if(directionRemi == "droite"){
    angle <- pi/2
  } else if(directionRemi == "haut"){
    angle <- 0
  } else if(directionRemi == "bas"){
    angle <- pi
  }
  
  # Si Rémi doit tourner à (droite/gauche) au premier tournant, alors l'angle sera modifier
  if(changementdirection1 == "droite"){
    angle2 <- pi/2
  } else if(changementdirection1 == "gauche"){
    angle2 <- -pi/2
  }
  
  # Pour chaque mouvement de style "L", on calcule la coordonnée de Rémi au creux et à la fin du "L"
  for (i in 1:nbmouvement){
    xy[2*i,] <- c(xy[2*i-1,1] + sin(angle)*distance1, xy[2*i-1,2] + cos(angle)*distance1)
    xy[2*i+1,] <- c(xy[2*i,1] + sin(angle + angle2)*distance2, xy[2*i,2] + cos(angle + angle2)*distance2)
  }
  
  # On ajoute la dernière ligne droite nécessaire
  xy[2*nbmouvement+2,] <- c(xy[2*nbmouvement+1,1] + sin(angle)*distance1, xy[2*nbmouvement+1,2] + cos(angle)*distance1)
  return(xy)
}
```

```{r}
section1 <- round(mouvement(0,0,"droite",50,30,"droite",2)) # Besoin de 6 paires de coordonnées.
section1
```

---

# Exemple 6 (solution: suite)

Pour la section 2, on remarque que la *coordonnée initiale* doit être la coordonnée finale de la section 1. De plus, Rémi doit regarder vers le *bas*, puis tourner à *gauche* en premier (pour effectuer le L). Le premier couloir est d'une longueur de *70 mètres*, alors qu'après le premier tournant, le couloir est d'une longueur de *60 mètres*. Il réalise *2 fois* un L, avant de devoir faire sa ligne droite supplémentaire.

```{r}
section2 <- mouvement(section1[6,1],section1[6,2],"bas",70,60,"gauche",2) # jusqu'à 6
section2
```

---

# Exemple 6 (solution: suite)

Pour la section 3, on remarque que la *coordonnée initiale* doit être la coordonnée finale de la section 2. De plus, Rémi doit regarder vers le *droite*, puis tourner à *gauche* en premier (pour effectuer le L). Le premier couloir est d'une longueur de *70 mètres*, alors qu'après le premier tournant, le couloir est aussi d'une longueur de *70 mètres*. Il réalise *3 fois* un L, avant de devoir faire sa ligne droite supplémentaire.

```{r}
section3 <- mouvement(section2[6,1],section2[6,2], "droite", 70,70,"gauche",3) # jusqu'à 8
section3
```

---

# Exemple 6 (solution: suite)

Pour la section 4, on remarque à l'aide du triangle rectangle qu'au final, Rémi aura parcouru 120 mètres en x (vers la gauche), et 50 mètres en y (vers le haut).

Ainsi, on doit ajouter le vecteur (-120,50) à la dernière coordonnée de la section 3.

```{r}
section4 <- section3[8,] + c(-120,50)
section4
```

---

# Exemple 6 (solution: suite)


```{r}
matfinal <- rbind(section1,section2,section3,section4)
matfinal # rbind() pour combiner toutes les matrices ensembles:
```

---

# Exemple 6 (solution: suite)

Notons que deux lignes sont inutiles. Effectivement, la coordonnée finale de la section 1 se répète avec la coordonnée initiale de la section 2. Le même problème survient pour la coordonnée finale de la section 2 et la coordonnée initiale de la section 3. 

Pour enlever la ligne 7 et 13, il suffit d'écrire:

```{r, eval=FALSE}
matfinal[-c(7,13),]
```

Le signe négatif indique que l'élément sera supprimé. Comme il s'agit d'une matrice, on note que l'élément *matfinal[7,]* qui correspond à la $7^e$ ligne et l'élément *matfinal[13,]* qui correspond à la $13^e$ ligne seront supprimés.
   
   
---
class: inverse, middle, center

# Exercices supplémentaires de l'atelier 3
<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>


---

# Exemple 1

Une compagnie travaille dans la farine. Leur branche principale est la conception de différente grandeur de sac de farine. Par contre, dernièrement, plusieurs plaintes ont été reçues au département des sacs de 250g. Certaines par des clients, spécifiant que leur sac de farine était beaucoup plus léger que 250g, et certaines par les directeurs, qui dans un sens contraire, affirmait que certains sacs étaient beaucoup trop remplis et dépassait 250g. 

En regardant les réglages de la machine, on remarque que cette dernière crée des sacs de 250g en moyenne, dont l’écart-type est de 5g. La quantité de farine introduite dans les sacs suit une loi normale. 

- Simulez d’abord 1000 données suivant ces caractéristiques

---

# Exemple 1 (suite)

En statistique, il est fréquent de transformer des données en données centrées réduites. Pour ce faire, il suffit, pour chacune des 1000 valeurs, de leur soustraire la moyenne théorique, puis de diviser ce résultat par l’écart-type théorique.

-	Créez un nouveau vecteur des valeurs centrées réduites.
-	Afin de nous aider à visualiser les nouvelles données, représentez-les graphiquement à l’aide de la fonction plot(). 

*Rappelons que le premier argument doit être les valeurs sur l’axe des x (soit des valeurs de 1 à 1000 représentants chacune des données) et que le deuxième argument doit être les valeurs en y (les valeurs centrées réduites).

---

# Exemple 1 (suite)

Dans cet exemple, nous considérerons comme valeurs extrêmes les points du graphique obtenu qui seront sous (-3) ou au-dessus de (3). Statistiquement, toutes ces valeurs extrêmes signifient qu’elles se situent à plus de 3 écarts-types de la moyenne réelle.
Exemple : $250 + 3*5 = 265$ (à partir de 265)   OU   $250 – 3*5 = 235$ (sous 235).

-	Créez un nouveau vecteur affichant 1 si la valeur centrée réduite est supérieure à 3 ou inférieure à -3, et 0 sinon.
-	Calculez combien de valeurs centrées réduites sont supérieures à 3 ou inférieures à 3 en utilisant le vecteur créé à la question précédente. 
-	Finalement, si le nombre de valeurs (qui représente le nombre de sacs) est strictement supérieur à 2, on souhaite afficher à l’écran que la machine est défectueuse. Dans un cas contraire, on affichera qu’il n’y a aucun problème avec la machine.

*La création d'une fonction effectuant toutes les étapes pourrait vous être utile*


---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 1 (solution)

```{r}
sac_farine <- rnorm(n = 1000, mean = 250, sd = 5) # 1000 sacs, moyenne de 250 et é.t de 5
sac_farine_cr <- (sac_farine-250)/5 # centrer et réduire les sacs
```

---

# Exemple 1 (solution: suite)

```{r}
plot(c(1:1000),sac_farine_cr) # On affiche le graphique
```

---

# Exemple 1 (solution: suite)

```{r}
vec <- numeric(length(sac_farine)) # Création d'un vecteur de 1000 positions de 0
vec[sac_farine_cr > 3 | sac_farine_cr < -3] <- 1 # Vectoriellement au lieu d'une boucle
# si sac_farine_cr > 3 OU si sac_farine_cr < -3, alors on assigne la valeur 1 (pour chaque position)

nb_sac_extreme <- sum(vec) # En effectuant la somme de vec, on obtient combien de valeurs extrêmes
nb_sac_extreme             # (qui dépasse 3 ou -3) nous avions dans l'échantillon de 1000 sacs.

if(nb_sac_extreme > 2){
  print("La machine est clairement défectueuse")
} else {
  print("Il n'y a aucun problème avec la machine")
}
```

---

# Exemple 1 (sous forme d'une fonction)

```{r}
calcul_sac <- function(sac_farine){
  ecart_moy <- mean(sac_farine) - 250
  ecart_et <- sd(sac_farine) - 5
  sac_farine_cr <- (sac_farine-250)/sd(sac_farine)
  vec <- numeric(length(sac_farine))
  vec[sac_farine_cr > 3 | sac_farine_cr < -3] <- 1
  nb_sac_extreme <- sum(vec)
  if(nb_sac_extreme > 2){
    print("La machine est clairement défectueuse")
  } else {
    print("Il n'y a aucun problème avec la machine")
  }
  return(nb_sac_extreme)
}
```

---

# Exemple 1 (sous forme d'une fonction)

```{r}
calcul_sac(rnorm(n = 1000, mean = 250, sd = 5))
calcul_sac(rnorm(n = 1000, mean = 250, sd = 5))
calcul_sac(rnorm(n = 1000, mean = 250, sd = 5))
```

---

# Exemple 2

Dans cet exercice, on souhaite représenter graphiquement la fonction $0.0002x^3 – 0.01x^2 + 2$.

Pour ce faire, créez une boucle évaluant la fonction pour des valeurs de x allant de -100 à 100. Gardez ces valeurs dans un vecteur y.
Dans les arguments du graphique, ajouter la commande permettant de relier les points à l’aide de ligne.

** *?plot pourrait vous être utile.**

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 2 (solution)

```{r}
y <- numeric(201)

for (x in -100:100){
  y[x+101] <- 0.0002*x^3 - 0.01*x^2 + 2 # On commence à remplir y à la position -100 + 101 = 1
}

```

---

# Exemple 2 (solution: suite)

```{r}
plot(c(-100:100),y, type = "l")
```


---

# Exemple 3

Un nouveau jeu vient de sortir au casino. Venez tester votre chance!

Première étape (lancer de la pièce de monnaie): Lancez votre pièce de monnaie jusqu’à obtenir la valeur FACE.

Deuxième étape (lancer du dé): Lancez votre dé jusqu’à obtenir la valeur 3.

Troisième étape (lancer de deux dés): Lancez vos deux dés et additionnez les valeurs obtenues. Le but est d’obtenir une valeur de 9 ou plus.

Créer une fonction qui permet de réaliser l’expérience N fois. 
Réalisez cette expérience 10000 fois et calculez le nombre de lancers moyen (total) afin de terminer l’ensemble des trois étapes.

---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 3 (solution)

Lancer de la pièce de monnaie:

```{r}
piece <- c("pile","face") # les deux valeurs de la pièce
obtenir_face <- 0
nb_step_face <- 0

while(obtenir_face != "face"){
  obtenir_face <- sample(piece,1)
  nb_step_face <- nb_step_face + 1
}
```

Lancer du dé

```{r}
de <- c(1:6) # les 6 valeurs du dé
obtenir_3 <- 0
nb_step_de <- 0

while(obtenir_3 != 3){
  obtenir_3 <- sample(de,1)
  nb_step_de <- nb_step_de + 1
}
```

---

# Exemple 3 (solution: suite)

Lancer des deux dés

```{r}
deuxde <- c(1:6) # les 6 valeurs des deux dés
somme_de <- 0
nb_step_de_add <- 0

while(somme_de < 9){
  de1 <- sample(deuxde,1)
  de2 <- sample(deuxde,1)
  somme_de <- de1 + de2
  nb_step_de_add <- nb_step_de_add + 1
}
```

Somme des essais

```{r}
essai <- nb_step_face + nb_step_de + nb_step_de_add
```

---

# Exemple 3 (solution: suite)



```
calcul_essai <- function(N){
essai <- numeric(N)
    for (i in 1:N){
    piece <- c("pile","face") # Lancer de la pièce
    obtenir_face <- 0
    nb_step_face <- 0
    while(obtenir_face != "face"){
      obtenir_face <- sample(piece,1)
      nb_step_face <- nb_step_face + 1
    }
    de <- c(1:6) # Lancer du dé
    obtenir_3 <- 0
    nb_step_de <- 0
    while(obtenir_3 != 3){
      obtenir_3 <- sample(de,1)
      nb_step_de <- nb_step_de + 1
    }
    ### Suite à la prochaine diapositive
```

---

# Exemple 3 (solution: suite)

```
### Suite ici
deuxde <- c(1:6) # Lancer des deux dés
    somme_de <- 0
    nb_step_de_add <- 0
    while(somme_de < 9){
      de1 <- sample(deuxde,1)
      de2 <- sample(deuxde,1)
      somme_de <- de1 + de2
      nb_step_de_add <- nb_step_de_add + 1
    }
    essai[i] <- nb_step_face + nb_step_de + nb_step_de_add
    }
 return(essai)
}
```

Remarquons que pour calculer la fonction N fois, l'argument prend simplement N, qui reproduit une boucle à l'intérieur de notre fonction.

---

# Exemple 3 (solution: suite)

Ainsi, on obtient

```{r, echo=FALSE}
calcul_essai <- function(N){
essai <- numeric(N)
    for (i in 1:N){
    piece <- c("pile","face") # les deux valeurs de la pièce
    obtenir_face <- 0
    nb_step_face <- 0
    while(obtenir_face != "face"){
      obtenir_face <- sample(piece,1)
      nb_step_face <- nb_step_face + 1
    }
    de <- c(1:6) # les 6 valeurs du dé
    obtenir_3 <- 0
    nb_step_de <- 0
    while(obtenir_3 != 3){
      obtenir_3 <- sample(de,1)
      nb_step_de <- nb_step_de + 1
    }
    deuxde <- c(1:6) # les 6 valeurs des deux dés
    somme_de <- 0
    nb_step_de_add <- 0
    while(somme_de < 9){
      de1 <- sample(deuxde,1)
      de2 <- sample(deuxde,1)
      somme_de <- de1 + de2
      nb_step_de_add <- nb_step_de_add + 1
    }
    essai[i] <- nb_step_face + nb_step_de + nb_step_de_add
    }
return(essai)
}
```

```{r}
resultat <- calcul_essai(10000)
resultat[1:10] # idée des 10 première tentatives
mean(resultat) # Moyenne du nombre de lancer total
```



---

# Exemple 4

Au moyen du fichier [individu.csv](./donnees/individu.csv), je vous demande de faire les opérations suivantes:

- Trouvez d'abord la moyenne d'âge
- Déterminez la proportion d'individus âgés de 45 ans et plus qui sont en couple (représenté par le codage 1)
- Finalement, déterminez le nombre moyen d'animaux qu'un individu en couple possède. Faites de même pour les individus seuls.
- Que peut-on conclure des résultats obtenus?


---

class: inverse, middle, center

# Solution à la prochaine diapositive
<hr width="65%" size="0.3" color="green" style="margin-top:-20px;"></hr>


---

# Exemple 4 (solution)

```{r}
donnees <- read.table(file = "./donnees/individu.csv", header = TRUE, sep = ";", row.names = 1)

# Trouver la moyenne d'âge
age <- donnees[,1]
moy_age <- mean(age)
moy_age
```

---

# Exemple 4 (solution: suite)

```{r}
# Déterminer la proportion d'individu âgé de 45 ans et plus qui sont en couple (1)
couple <- donnees[,2]

nb_indiv <- numeric(50)
nb_indiv[age >= 45 & couple == 1] <- 1

prop_indiv <- sum(nb_indiv)/length(nb_indiv)
prop_indiv
```

---

# Exemple 4 (solution: suite)

```{r}
# Nombre moyen d'animaux par couple/seul
animaux <- donnees[,3]

nb_coup <- sum(couple) # Nombre de personne en couple
nb_seul <- 50 - nb_coup # Nombre de personne seul (50 - nombre en couple)
anim_coup <- numeric(50) # Vecteur de 0
anim_seul <- numeric(50) # Vecteur de 0

for (i in 1:50){
  if(couple[i] == 1){
    anim_coup[i] <- animaux[i]
  } else if (couple[i] == 0){
    anim_seul[i] <- animaux[i]
  }
}
moy_coup <- sum(anim_coup)/nb_coup
moy_seul <- sum(anim_seul)/nb_seul

c(moy_coup, moy_seul)
```










